#First Problem
class Solution(object):
    def findErrorNums(self, nums):
        n = len(nums)
        S = n * (n + 1) // 2
        P = n * (n + 1) * (2 * n + 1) // 6
        
        S_prime = sum(nums)
        P_prime = sum(x * x for x in nums)
        
        diff = S - S_prime  
        sq_diff = P - P_prime 

        sum_diff = sq_diff // diff
        
        miss = (diff + sum_diff) // 2
        dup = sum_diff - miss
        
        return [dup, miss]



#Second Problem
class Solution(object):
    def inorder_traversal(self, root):
        elements = []
        
        def inorder(node):
            if not node:
                return
            inorder(node.left)
            elements.append(node.val)
            inorder(node.right)
        
        inorder(root)
        return elements

    def findTarget(self, root, k):
        elements = self.inorder_traversal(root)
        
        left, right = 0, len(elements) - 1
        
        while left < right:
            current_sum = elements[left] + elements[right]
            if current_sum == k:
                return True
            elif current_sum < k:
                left += 1
            else:
                right -= 1
        
        return False




